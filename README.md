# Simple Blockchain Simulation in Python

A command-line Python application that simulates a basic blockchain, demonstrating core concepts like blocks, transactions, hashing, Proof-of-Work (including mining time display), and chain validation. The simulation state can be saved to and loaded from a JSON file for persistence.

## Features

- **Block Creation:** Implements `Block` objects containing an index, a list of transactions, a timestamp, the hash of the previous block, a nonce, and its own calculated SHA-256 hash.
- **Transaction Management:** Allows creation of `Transaction` objects (sender, recipient, amount) with basic validation and manages a pool of pending transactions.
- **Proof-of-Work (PoW):** Includes a simple PoW algorithm where miners search for a nonce that results in a block hash meeting a defined difficulty (number of leading zeros).
  - **Difficulty:** Configurable when a new blockchain is created.
  - **Mining Time Display:** The CLI shows how long each mining operation (PoW search) takes.
- **Mining Rewards:** A conceptual reward is granted to the miner for successfully creating and adding a new block to the chain.
- **Chain Validation:** A robust validation mechanism checks for:
  - Integrity of each block's hash (data tampering).
  - Correctness of the `previous_hash` links between blocks (chain integrity).
  - Validity of the Proof-of-Work for each block against the current difficulty.
- **Interactive CLI:** A user-friendly command-line interface allows users to:
  - Add new transactions.
  - Mine pending transactions to create new blocks.
  - Display the entire blockchain's current state in a detailed format.
  - Validate the integrity of the blockchain.
  - View transactions currently in the pending pool.
- **Persistence:** The entire state of the blockchain (chain, pending transactions, difficulty, mining reward) can be saved to a `blockchain_data.json` file and loaded automatically on subsequent runs of the application. Users are also prompted to save on exit.

## Project Structure

The project is organized into the following Python modules:

simple_blockchain_py/
├── .gitignore # Specifies intentionally untracked files that Git should ignore
├── block.py # Defines the Block class and its functionalities
├── blockchain.py # Defines the Blockchain class, containing core logic, PoW, validation, save/load
├── main.py # Provides the Command-Line Interface (CLI) for user interaction
├── transaction.py # Defines the Transaction class
├── blockchain_data.json # (Generated by the app) Stores the saved state of the blockchain
└── venv/ # Python virtual environment (excluded by .gitignore)

## Requirements

- Python 3.7 or higher. (No external libraries are strictly required beyond the standard library modules like `hashlib`, `json`, and `time`).

## Setup and Running

1.  **Clone the Repository (Optional):**
    If you have this project hosted on a Git platform (like GitHub), clone it. Otherwise, ensure you have the project files in a local directory.

    ```bash
    # git clone <your-repository-url>
    # cd simple_blockchain_py
    ```

    If you downloaded the files directly, navigate into the `simple_blockchain_py` directory.

2.  **Create and Activate a Python Virtual Environment (Recommended):**
    This isolates project dependencies.

    ```bash
    # Navigate to your project directory (e.g., simple_blockchain_py)
    python3 -m venv venv
    ```

    Activate the environment:

    - **On macOS/Linux:**
      ```bash
      source venv/bin/activate
      ```
    - **On Windows (Command Prompt):**
      ```bash
      venv\Scripts\activate.bat
      ```
    - **On Windows (PowerShell):**
      ```bash
      venv\Scripts\Activate.ps1
      ```
      (If PowerShell activation fails, you might need to run `Set-ExecutionPolicy Unrestricted -Scope Process` first in that PowerShell session.)

3.  **Run the Application:**
    Execute the `main.py` script using Python:

    ```bash
    python3 main.py
    ```

4.  **Interact with the CLI:**
    Upon running, the application will:
    - Attempt to load an existing blockchain from `blockchain_data.json`.
    - If not found (or if loading fails), it will prompt you to set a **mining difficulty** for a new blockchain.
    - A menu will then be displayed, allowing you to:
      - **Add transactions:** Specify sender, recipient, and amount.
      - **Mine blocks:** Process pending transactions and perform Proof-of-Work. The time taken for mining will be displayed.
      - **Display blockchain:** View all blocks and their contents.
      - **Validate chain:** Check the integrity of the blockchain.
      - **View pending transactions:** See transactions awaiting mining.
      - **Save blockchain:** Manually save the current state to `blockchain_data.json`.
      - **Exit:** Terminate the application (with an option to save the current state).

## How It Works - Core Concepts

### Transaction (`transaction.py`)

A simple class representing a transfer of value, containing `sender`, `recipient`, and `amount`. It includes basic validation (e.g., amount must be positive) and can be converted to a dictionary for easy serialization.

### Block (`block.py`)

The fundamental unit of the blockchain. Each `Block` object stores:

- `index`: Its position in the chain.
- `transactions`: A list of transaction dictionaries included in the block.
- `timestamp`: The time of its creation.
- `previous_hash`: The hash of the block that came before it, linking the chain.
- `nonce`: A number found during the mining process (Proof-of-Work).
- `hash`: The block's own cryptographic hash (SHA-256), calculated based on all its content (including the nonce). This hash uniquely identifies the block and secures its data.

### Blockchain (`blockchain.py`)

The main class orchestrating the simulation:

- **Chain:** A list holding all `Block` objects in sequence.
- **Pending Transactions:** A pool for `Transaction` objects that have been submitted but not yet included in a block.
- **Genesis Block:** The first block (index 0) is automatically created for a new blockchain if no existing data is loaded.
- **Adding Transactions:** New transactions are validated (via the `Transaction` class) and added to the pending pool.
- **Mining & Proof-of-Work (PoW):**
  - When `mine_pending_transactions` is called, pending transactions (plus a reward for the miner) are bundled into a new block.
  - The PoW algorithm (`proof_of_work` method) then iteratively tries different `nonce` values. For each `nonce`, it recalculates the block's hash until a hash is found that meets the `difficulty` target (e.g., starts with a certain number of leading zeros).
  - The time taken for this PoW search is measured and reported.
  - The successfully "mined" block (with its valid nonce and hash) is then added to the chain, and pending transactions are cleared.
- **Validation (`is_chain_valid()`):** This crucial method ensures the blockchain's integrity by performing several checks on each block:
  1.  **Data Integrity:** Verifies that each block's stored `hash` is correct by recalculating it from the block's content and its stored `nonce`.
  2.  **Link Integrity:** Ensures that the `previous_hash` of each block correctly matches the `hash` of the actual preceding block in the chain.
  3.  **Proof-of-Work Validity:** Confirms that the `hash` of each block satisfies the Proof-of-Work difficulty requirement.
- **Persistence (`save_to_file()`, `load_from_file()`):** The entire state of the blockchain (the chain of blocks, any pending transactions, the current difficulty, and the mining reward value) is converted to a JSON-serializable format. This state can be saved to `blockchain_data.json` and is automatically loaded when the application starts, allowing the simulation to resume.

## Future Enhancements (Potential Ideas)

- **Account Balances:** Implement logic to calculate and display balances for addresses based on transaction history.
- **More Sophisticated Transaction Validation:** Add checks for sufficient funds before adding a transaction (requires balance tracking).
- **Network Simulation:** Extend the concept to simulate multiple nodes, consensus mechanisms beyond simple PoW, and block propagation (a significantly more complex endeavor).
- **Alternative Consensus (Conceptual):** Explore how other consensus mechanisms like Proof-of-Stake might be simulated at a high level.
- **Web Interface:** Develop a simple web-based UI (e.g., using Flask or Django) as an alternative or addition to the CLI.
- **Transaction Signatures:** Introduce cryptographic signatures for transactions to verify sender authenticity (requires incorporating public/private key cryptography libraries).
